#include <iostream>
#include <fstream>
#include <vector>
#include <random>
#include <chrono>
#include <mutex>
#include <condition_variable>
#include <tbb/concurrent_queue.h>
#include <tbb/parallel_for.h>

// 计时器函数
auto time_cout() {
    return std::chrono::high_resolution_clock::now().time_since_epoch().count();
}

class DataProcessor {
private:
    tbb::concurrent_queue<std::vector<double>> data_queue;
    int num_threads;
    int num_iterations;
    std::vector<std::vector<double>> timing_data;
    std::mutex data_mutex;  // 添加一个 std::mutex 成员变量
    std::condition_variable data_cond;

public:
    DataProcessor(int threads, int iterations) : num_threads(threads), num_iterations(iterations) {
        timing_data.resize(num_threads, std::vector<double>(num_iterations * 2));
    }

    void processData() {
        // 随机数生成器初始化
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<double> dis(0.0, 1.0);

        // 创建10个线程的并行任务
        
        tbb::parallel_for(0, num_threads, 1, [&](int i) {
            for (int j = 0; j < num_iterations; ++j) {
                // 生成随机数
                std::vector<double> random_numbers(1024);
                for (double& num : random_numbers) {
                    num = dis(gen);
                }
                auto send_start = time_cout();
                // 将随机数发送给序号比自己大的下一个线程
                int next_thread_index = (i + 1) % num_threads;
                {
                    std::lock_guard<std::mutex> lock(data_mutex);
                    data_queue.push(random_numbers);
                }
                data_cond.notify_one();
                //auto send_end = time_cout();
                //auto send_duration = send_end + send_start ;
                //auto receive_start = time_cout()
                std::vector<double> received_data;
                {
                    std::unique_lock<std::mutex> lock(data_mutex);
                    data_cond.wait(lock, [this] { return !data_queue.empty(); });
                    data_queue.try_pop(received_data);
                }

                auto receive_end = time_cout();
                auto receive_duration = (receive_end - send_start)*1.0/1000;

                // 存储发送和接收数据的时间到二维数组
                //timing_data[i][j * 2] = send_duration;
                timing_data[i][j * 2 + 1] = receive_duration;
            }
            });
    }

    void writeCSV(std::string filename) {
        // 将数据写入CSV文件
        std::ofstream csv_file(filename);
        for (int i = 0; i < num_iterations; ++i) {
            for (int j = 0; j < num_threads; ++j) {
                csv_file << timing_data[j][i * 2 + 1];
                if (j != num_threads - 1) {
                    csv_file << ",";
                }
                else {
                    csv_file << std::endl;
                }
            }
        }
        csv_file.close();
    }
};

int main() {
    // 创建DataProcessor对象
    DataProcessor processor(10, 50000);

    // 处理数据
    processor.processData();

    // 将数据写入CSV文件
    processor.writeCSV("timing_data.csv");

    return 0;
}
